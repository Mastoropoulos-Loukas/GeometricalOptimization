# Polygon Generation

Περιεχόμενα <br>
[Περιγραφή](#a-περιγραφή)
[Δομή Κώδικα](#β-δομή-κώδικα)
[Μεταγλώττιση](#γ-μεταγλώττιση)
[Οδηγίες Χρήσης](#δ-οδηγίες-χρήσης)
[Φοιτήτες](#ε-φοιτητές)
[Incremental](#incremental)
[Convex Hull](#convex-hull)
[Onion](#onion)

## A. Περιγραφή
<p>
    Το πρόγραμμα υπολογίζει ένα απλό κλειστό πολύγωνο το οποίο διέρχεται από όλα τα σημεία ενός δοσμένου συνόλου. Αξιοποιεί τρεις αλγορίθμους με διάφορες παραμέτρους για τον κάθε ένα. Υπολογίζει το εμβαδόν του τελικού πολυγώνου και με την χρήση του αλγορίθμου Pick, ο οποίος έχει υλοποιηθεί εξ αρχής. Παράγει ένα αρχείο εξόδου με αποτελέσματα σχετικά με το παραγόμενο πολύγωνο. 
</p>
<br>

## Β. Δομή Κώδικα
<ul>
<li>
<b>main.cpp</b><br>
Στο αρχείο αυτό αξιοποιούνται όλα τα άλλα και έχει γραφεί η main συνάρτηση. Εδώ γίνεται ο έλεγχος των ορισμάτων, το διάβασμα τις εισόδου, η διαχείριση της παραμετρικής λειτουργίας του προγράμματος και η παραγωγή του/των αρχείου/αρχείων εξόδου. <br>
</li>
<li>
<b>shared.h</b><br>
    Τα κοινά header αρχεία που γίνονται include από τα αρχεία υλοποίησης των αλγορίθμων, κοινός ορισμός typedef για ομοιότητα στον κώδικα και ορισμός structs και enums για την να είναι πιο ευανάγνωστος ο κώδικας στην main συνάρτηση.
</li>
<li>
<b>PolygonGenerator.h</b><br>
    Ορισμός abstract κλάσης που περιγράφει την γενική λειτουργία ενός αλγόριθμου που παίρνει σημειοσύνολο ως είσοδο και παράγει ένα απλό πολύγωνο που διέρχεται από όλα τα σημεία. Κάθε κλάση που υλοποιεί έναν αλγόριθμο, είναι υποκλάση αυτής. 
</li>
<li>
<b>incr.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αυξητικό αλγόριθμο (incremental).
</li>
<li>
<b>incr.cpp</b><br>
    Υλοποίηση κλάσης που χρησιμοποιεί τον αυξητικό αλγόριθμο για την παραγωγή του ζητούμενου πολυγώνου.
</li>
<li>
<b>ConvexHullAlgo.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αλγόριθμο convex hull.
</li>
<li>
<b>ConvexHullAlgo.cpp</b><br>
    Υλοποίηση κλάσης που χρησιμοποιεί τον αλγόριθμο convex hull για την παραγωγή του ζητούμενου πολυγώνου.
</li>
<li>
<b>onion.h</b><br>
    Ορισμός κλάσης που υλοποιεί τον αλγόριθμο onion και συναρτήσεων της.
</li>
<li>
<b>onion.cpp</b><br>
    Υλοποίηση κλάσης που χρησιμοποιεί τον αλγόριθμο onion για την παραγωγή του ζητούμενου πολυγώνου.
</li>
<li>
<b>Pick.h</b><br>
    Ορισμός της συνάρτησης που υπολογίζει το εμβαδόν ενός πολυγώνου βάσει του αλγόριθμου Pick
</li>
<li>
<b>Pick.cpp</b><br>
    Υλοποίηση της συνάρτης που υπολογίζει το εμβαδόν ενός πολυγώνου βάσει του αλγόριθμου Pick
</li>
<li>
<b>pythonQgisScript.py</b><br>
    Python script που αξιοποεί τα WKT αρχεία που παράγει το πρόγραμμα (αν δώσουμε το flag -show_shapes) για το λογισμικό QGIS. Για να αξιοποιηθεί χρειάζεται να έχουμε βάλει στο QGIS την επέκταση QuickWKT και να αλλάξουμε την τιμή της μεταβλητής exeDir στο full path του καταλόγου του εκτελέσιμου.
</li>
</ul>
<br>

## Γ. Μεταγλώττιση
Στον κατάλογο που βρίσκονται τα πηγαία αρχεία <br>
<code>
    cgal_create_CMakelists -s to_polygon <br>
    cmake -DCGAL_DIR = path-to-cgal-dir .<br>
    make <br>
</code>
όπου path-to-cgal-dir το path στον κατάλογο CGAL
<br>

## Δ. Οδηγίες Χρήσης
<code>
    ./to_polygon -i "input-file" -o "output-file" -algorithm "algorithm" [FLAGS] <br>
</code>
    όπου: <br>
    <ul>
    <li>"input-file" το αρχείο εισόδου με τα σημεία υπό την μορφή που περιγράφεται στην εκφώνηση</li>
    <li>"output-file" το αρχείο εξόδου που θέλουμε να παραχτεί. Περιέχει τα αποτελέσματα υπό την μορφή που περιγράφονται στην εκφώνηση</li>
    <li>"algorithm" μία από τις τιμές: incremental, convex_hull, onion για τον αντίστοιχο αλγόριθμο</li>
    <li>[FLAGS]:<br>
        Για να μην υπολογιστεί το εμβαδόν με τον αλγόριθμο Pick (επειδή παίρνει πολύ χρόνο): <code>-hide_pick</code><br>
        Για να παραχτούν WKT αρχεία με το σημειοσύνολο (points.wkt), το κυρτό περίβλημα (hull.wkt) και το παραγόμενο πολύγωνο (polygon.wkt) στον κατάλογο του εκετελέσιμου: <code>-show_shapes</code>
        Για τον κάθε αλγόριθμο: <br>
        <ul>
            <li>Για τον incremental:<br>
                <code>-edge_selecetion</code>. Δυνατές τιμές:<br>
                1 για τυχαία επιλογή ακμής<br>
                2 για επιλογή ακμής με που προσθέτει το ελάχιστο εμβαδόν<br>
                3 για την επιλογή ακμής με που προσθέτει το μέγιστο εμβαδόν <br>
                <code>-initialization</code>. Δυνατές τιμές:<br>
                1a, 2a, 1b, 2b που προσφέρουν την λειτουργικότητα που περιγράφεται στην εκφώνηση
            </li>
            <li>Για τον convex_hull:<br>
                <code>-edge_selecetion</code>. Δυνατές τιμές:<br>
                1 για τυχαία επιλογή ακμής<br>
                2 για επιλογή ακμής με που προσθέτει το ελάχιστο εμβαδόν<br>
                3 για την επιλογή ακμής με που προσθέτει το μέγιστο εμβαδόν <br>
            </li>
            <li>Για τον onion:<br>
                <code>-onion_initialization</code>. Δυνατές τιμές:<br>
                1, 2, 3, 4, 5 που προσφέρουν την λειτουργικότητα που περιγράφεται στην εκφώνηση
            </li>
        </ul>
    </li>
    </ul>
    Παράδειγματα εκτέλεσης: <br>
    <code>./to_polygon -i ../instances/data/images/euro-night-0000020.instance -o test.txt -algorithm onion -onion_initialization 1 -hide_pick</code><br>
    <code>./to_polygon -i ../instances/data/images/euro-night-0000020.instance -o test.txt -algorithm incremental -edge_selection 1 -initialization 1a -show_shapes</code><br>
    <code>./to_polygon -i ../instances/data/images/euro-night-0000020.instance -o test.txt -algorithm convex_hull -edge_selection 1 -hide_pick</code><br>
    
<br>

## Ε. Φοιτητές

Λουκάς Μαστορόπουλος &nbsp; 1115 2017 00078 <br>
Νικόλαος Χαρίσης &nbsp; 1115 2017 00187 <br>
Θάνος Βάιος   &nbsp;  &nbsp;  1115 2018 00016 <br>

## Incremental
Δομές:<br>
<ul>
<li></li>
</ul>

Κύρια Λειτουργία:<br>
<ul>
<li></li>
</ul>

Λοιπές Συναρτήσεις:<br>
<ul>
<li></li>
</ul>

Σημειώσεις / Σχεδιαστικές Επιλογές:<br>
<ul>
<li></li>
</ul>

Αποτελέσματα Εκτελέσεων και Σχολιασμός:<br>
<ul>
<li></li>
</ul>
<br>

## Convex Hull

Δομές:<br>
<ul>
<li></li>
</ul>

Κύρια Λειτουργία:<br>
<ul>
<li></li>
</ul>

Λοιπές Συναρτήσεις:<br>
<ul>
<li></li>
</ul>

Σημειώσεις / Σχεδιαστικές Επιλογές:<br>
<ul>
<li></li>
</ul>

Αποτελέσματα Εκτελέσεων και Σχολιασμός:<br>
<ul>
<li></li>
</ul>

<br>

## Onion
Δομές:<br>
<ul>
<li> Polygon_2 που αντιπροσωπευει τα κυρτά περιβλήμματα που δημιουργούνται καθώς και το τελικό πολύγωνο που επιστρέφεται. Από την CGAL</li>
<li>
 Point_2 που αντιπροσωπεύει τα σημεία του χώρου και τις ακμές των πολυγώνων. Από την CGAL
</li>
<li>
Segment_2 για την αναπαράσταση των ακμών ανάμεσα σε διάφορα σημεία. Από την CGAL
</li>
<li>
Vector που χρησιμοποιείται για την αποθήκευση των σημείων και των κυρτών περιβλημάτων. Από την STL
</li>
</ul>

Κύρια Λειτουργία:<br>
<ul>
Το onion.cpp υλοποιεί κατά βάση 2 πράγματα. Τον constructor της κλασης OnionAlgo και την συνάρτηση generatePolygon.
<li> <code> OnionAlgo </code>: <br> <br>
<p> Ο Constructor αρχικά καλεί τον constructor της υπερκλασης PolygonGenerator με όρισμα το list. Στη συνέχεια αρχικοποιεί το πεδίο option με βάση ό,τι έχει δωθεί
</p>
</li>
<li><code> generatePolygon</code>: <br> <br>
<p> Στην συνάρτηση αυτή είναι που γίνεται και όλη η δουλεία αφού υπολογίζει το ζητούμενο πολύγωνο με βάση των αλγόριθμο των επάλληλων ΚΠ. Αρχικά σώζει τα σημεία σε έναν vector. Έπειτα υπογίζει όλα τα ΚΠ (ο υπολογισμός του ΚΠ είναι verbatim από το user manual της CGAl σχετικά με τα ΚΠ). Για κάθε σημείο που ανήκει στο ΚΠ, το αφαιρει απο τον vector των σημείων και το βαζει σε ενα πολύγωνο, το οποίο στο τέλος μπαίνει και αυτό σε ένα vector πολυγώνων. Η παραπάνω διαδικασία επαναλαμβάνεται μέχρις ότου να μείνουν λιγότερα από 3 σημεία στον αρχικό vector.
</p>
<p>Στη συνέχεια διατρέχουμε τον vector με τα πολύγωνα εφαρμόζοντας τον αλγόριθμο του κρεμμυδίου. Επιλέγουμε την m-οστή κορυφή(που αντιστοιχεί και στην m-οστη ακμή) και βρίσκουμε τη κοντινότερη κορυφή k στο ΚΠ βάθους i+1(στην πράξη κοιτάμε στο πολύγωνο που βρίσκεται στην θέση i+1 στον vector των πολυγώνων).Ελέγχουμε αν τα σημεία m και k είναι ορατά μεταξύ τους. Αν δεν είναι, πρέπει αναγκαστικά να επιλέξουμε άλλο m. Έπειτα, παίρνουμε τις κορυφές mPlus και λ που είναι γειτονικές στα m και λ αντίστοιχα και είναι ορατές μεταξύ τους. Αν δεν υπάρχουν τέτοιες κορυφές, πρέπει να βρούμε διαφορετικό m. Ελέγχουμε αν οι ακμες m-k και mPlus-λ τέμνονται μεταξύ τους. Αν ναι, τότε απλώς κάνουμε swap τις κορυφές m και m+1. Εν συνεχεία, σπάμε τις ακμές m-m+1 και k-λ
και ενώνουμε τα 2 πολύγωνα, μια διαδικασία που εξαρτάται από τις τιμές των m,mPlus,k και λ. Έπειτα, βρίσκουμε τα καινουργια m και m+1 κινούμενοι όπως περιγράφει ο αλγόριθμος, προσέχοντας μόνο να διαλέξουμε διαφορετικές κορυφές από τις αρχικές. Αντιστοιχούμε τις νέες κορυφές σε αυτές του "μεικτού" πολυγώνου και επαναλαμβάνουμε μέχρι να φτάσουμε στο τελικό βάθος
</p>
<p> Όταν φτάσουμε στο τελικό βάθος, διατρέχουμε το vector με τα αρχικά σημεία, ο οποίος πλέον περιέχει τα σημεία τα οποία δεν άνηκαν σε κάποιο ΚΠ κατα την κατασκευή των ΚΠ. Για να τα προσθέσουμε, βρίσκουμε τη κοντυνότερη κορυφή στο "μεικτό" πολύγωνο. Θα πρέπει τόσο αυτή, όσο και μία από τις γειτονικές της να είναι ορατές. Αν δεν είναι, τότε βρίσκουμε την 1η κορυφή του ΚΠ στο τελευταίο βάθος που είναι ορατή και πληροί της παραπάνω προϋποθέσεις ( ξέρουμε ότι σίγουρα θα ανήκει και στο "μεικτό" πολύγωνο, απλά πρέπει να κάνουμε την αντιστοιχία). 
</p>
<p> Τέλος, επιστρέφουμε το "μεικτό" πολύγωνο που δημιουργήθηκε από την παραπάνω διαδικασία
</p>
</li>
</ul>

Λοιπές Συναρτήσεις:<br>
<ul>
<p>Πέρα από τις βασικές συναρτήσεις που περιγράφηκαν πιο πάνω στο onion.cpp είναι ορισμένες και κάποιοες βοηθητικές συναρτήσεις.
</p>
<li><code>isVisible</code>:<br>
<p>
Η συγκεκριμένη συνάρτηση χρησιμοποιείται για να αποφανθεί αν ένα 2 σημεία είναι ορατά μεταξύ τους. Πρακτικά, παίρνει σαν όρισμα το ευθύγραμμο τμήμα που σχηματίζουν τα 2 σημεία και ελέγχει αν τέμνει το πολύγωνο σε ακριβώς 2 σημεία (θεωρούμε πως το initialEdge[1] είναι κορυφή του πολυγώνου poly).
</p>
</li>
<li><code>pointInPolygon</code>:<br>
<p>
Ελέγχει αν ένα σημείο βρίσκεται πάνω στη περιφέρεια του πολυγώνου, με το να τσεκάρει αν είναι συνευθειακό με κάποιο ζεύγος γειτονικών κορυφών του πολυγώνου
</p>
</li>
<li><code>getClosestK</code>:<br>
Επιστρέφει την κοντυνότερη κορυφή του πολυγώνου στο δωθέν σημείο. Η θέση του πολυγώνου επιστρέφεται στον indexClosestK
<p>
</p>
</li>
<li><code>getVertexIt</code>:<br>
<p>
Επιστρέφει τον Vertex_Iterator που αντιστοιχεί στην κορυφή
</p>
</li>
<li><code>nextIndex</code>:<br>
<p>
Επιστρέφει τον επόμενο δείκτη
</p>
</li>
<li><code>previousIndex</code>:<br>
<p>
Επιστρέφει τον προηγούμενο δείκτη
</p>
</li>
</ul>

Σημειώσεις / Σχεδιαστικές Επιλογές:<br>
<ul>
<p> Κατά την υλοποιήση του αλγορίθμου εμφανίστηκε η ανάγκη για την λήψη μερικών σχεδιαστικών επιλογών/αποφάσεων. Αυτές είναι:
</p>
<li> Ένα σημείο μπορεί να ανήκει σε 1 μόνο πολύγωνο/ΚΠ. Έτσι, κατά την κατασκευή των επάλληλων ΚΠ αν ένα σημείο βρεθεί να ανήκει στο ΚΠ του προηγούμενου βάθους απλά αγνοείται
</li>
<li> Η CGAL εμφανίζει πρόβλημα στην διαχείρηση πολυγώνων που δεν είναι στην πραγματικότητα πολύγωνο (πχ ένα πολύγωνο με 2 μόνο κορυφές). Έτσι, σε περίπτωση που φτάσουμε στο τελευταίο βάθος να έχουμε 3 σημεία τα οποία είναι όμως συνευθειακά, 1 από αυτά (το 2ο) αγνοείται.
</li>
<li> Αν κατά την επιλογή του m, το κοντινότερο σημείο k δεν είναι ορατό, αντί να αλλάξει το k, προτιμάτε να αλλάξει το m. Το σκεπτικό πίσω από αυτή την απόφαση είναι ότι το k επιλέγεται εξ αρχής έτσι ώστε να είναι το κοντινότερο
</li>
<li> Αν το μέγεθος του ΚΠ σε κάποιο βάθος είναι περιττός αριθμός, υπάρχει περίπτωση κατά την αντίρροπη κίνηση τους τα k και λ να συναντηθούν στην ίδια κορυφή.Αν συμβεί αυτό, τότε το λ προχωράει 1 βήμα παραπάνω με το k να το "περιμένει"
</li>
<li>Για την εισαγωγή των σημείων που έμειναν εκτός των ΚΠ, ψάχνουμε πρώτα για το κοντινότερο σημειο στο μεικτό πολύγωνο και σε περίπτωση που δεν πληροι τις προϋποθεσεις, ψάχνουμε στο τελευταιο ΚΠ. Αυτό γίνεται για να έχουμε μια παρόμοια φιλοσοφία με τον αλγόριθμο.
</li>
<li> Για την υλοποίηση της τυχαιότητας στην επιλογή της κορυφής χρησιμοποιήθηκε η συνάρτηση <code>rand()</code> αρχικοποιημένη με seed <code>time(0)</code>
</li>
</ul>

Αποτελέσματα Εκτελέσεων και Σχολιασμός:<br>
<ul>
Τα αποτελέσματα κάποιων ενδεικτικών εκτελέσεων υπάρχουν αναλυτικότερα στον φάκελο docs/ στο αντίστοιχο pdf.
Ένας πρόχειρος σχολιασμός αυτών είναι ο εξής:

<br><li>
<p>Σχετικά με τον χρόνο, ο αλγόριθμος αυτό τρέχει γρήγορα για εύλογο αριθμό σημείων. Φαίνεται να είναι πιο γρήγορος απο τους 2 προηγούμενους, χωρίς παρόλα αυτά να επιστρέφει καλύτρετα αποτελέσματα.
</p>
<p> Τα πολύγωνα που δημιουργούναι πληρούν τις προϋποθέσεις και περιλαμβάνουν όλα τα σημεία. Παρόλα αυτά, δεν είναι ιδιαίτερα σίγουρο πως το εμδαδόν που επιστρέφεται είναι το βέλτιστο. Στα πιο μεγάλα dataset, φαίνεται να υπάρχει μια τάση να επιστραφονται σχετικά μικρά εμβαδά, με λεπτά και μακρόστενα τρίγωνα.
</p>
<p>Γενικά, αν υπάρχει κάτι άξιο σχολιασμού, αυτό είναι η επιλογή της αρχικής κορυφής m, η οποία σίγουρα παίζει. Στα πιο αραια σημειοσύνολα η επιλογή αυτή έχει ξεκάθαρη επίπτωση στο εμβαδόν των πολυγώνων που δημιουργούνται, με κάποια πολύγωνα να ξεχωρίζουν. Παρόλα αυτά, όσο πυκώνουν τα dataset τόσο μικρότερη φαίνεται να είναι η επίδρασή της. Σίγουρα υπάρχουν διαφοροποιήσεις, αλλά είναι πιο μικρές. Πάντως, η εμπειρία κατά την υλοποιήση, την αποσφαλμάτωση και τον έλεγχο του ζητουμένου έδειξε πως μια αρκετά καλή επιλογή για m είναι η μεσαία κορυφή του 1ου ΚΠ.
</p>
</li>
</ul>
<br>